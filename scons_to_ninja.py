# Copyright (c) 2014 MongoDB, Inc. All rights reserved.

# Copyright (c) 2014 The Native Client Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import atexit
import itertools
import os
import sys

import SCons.Action
import SCons.Node
import SCons.Node.Python

# This implements a Ninja backend for SCons.  This allows SCons to be used
# as a Ninja file generator, similar to how Gyp will generate Ninja files.
#
# This is a way to bypass SCons's slow startup time.  After running SCons
# to generate a Ninja file (which is fairly slow), you can rebuild targets
# quickly using Ninja, as long as the .scons files haven't changed.
#
# The implementation is fairly hacky: It hooks PRINT_CMD_LINE_FUNC to
# discover the build commands that SCons would normally run.
#
# A cleaner implementation would traverse the node graph instead.
# Traversing the node graph is itself straightforward, but finding the
# command associated with a node is not -- I couldn't figure out how to do
# that.


# This is necessary to handle SCons's "variant dir" feature.  The filename
# associated with a Scons node can be ambiguous: it might come from the
# build dir or the source dir.
def GetRealNode(node):
    try:
        src = node.srcnode()
        if src.stat() is not None:
            return src
    except AttributeError:
        print "src - " + str(node)

    return node

def escape_path(word):
    try:
        return word.replace('$ ', '$$ ').replace(' ', '$ ').replace(':', '$:')
    except:
        print "Failed to escape : " + str(word)
        raise


def GenerateNinjaFile(env, dest_file):
    # Tell SCons not to run any commands, just report what would be run.
    env.SetOption('no_exec', True)
    # Tell SCons that everything needs rebuilding.
    env.Decider(lambda dependency, target, prev_ni: True)

    # Use a list to ensure that the output is ordered deterministically.
    node_list = []
    node_map = {}


    def CustomCommandPrinter(cmd, targets, source, env):
        if len(targets) != 1:
            print [str(a) for a in targets]
        #assert len(targets) == 1, len(targets)
        for t in targets:
            node = t
            # There can sometimes be multiple commands per target (e.g. ar+ranlib).
            # We must collect these together to output a single Ninja rule.
            if node not in node_map:
                node_list.append(node)
            node_map.setdefault(node, []).append(cmd)

    env.Append(PRINT_CMD_LINE_FUNC=CustomCommandPrinter)

    def filter_arg(a):
        if "ninja" in a or "mute" in a:
            return False

        if "scons" in a:
            return True

        if a.startswith("--") or "=" in a:
            return True

        return False

    def quote_arg(a):
        if "\"" in a:
            return a

        if " " in a:
            return "\"" + a + "\""

        return a

    def WriteFile():
        dest_temp = '%s.tmp' % dest_file
        ninja_fh = open(dest_temp, 'w')
        ninja_fh.write("""\
# Generated by scons_to_ninja.py

# Generic rule for handling any command.
rule cmd
  command = $cmd

# Rule to generate implicit dependencies by builtin header scanning
rule cc
  command = $cmd  -MMD -MF $out.d
  depfile = $out.d

""")

        unknown_targets = []

        posix = os.name == "posix"

        for node in node_list:

            dest_path = node.get_path()
            cmds = node_map[node]
            try:
                deps = [str(GetRealNode(dep).get_path()) for dep in node.all_children()]
                # deps = [d for d in deps if not "mongo\\config.h" ]
            except AttributeError:
                unknown_targets.append([dest_path, []])
                print "src2 - " + str(node)
                continue

            # Skip SCons config tests
            if "conftest" in dest_path or ".pdb" in dest_path:
                continue

            # deps = [GetRealNode(dep).get_path() for dep in node.all_children()]

            if "python" in " ".join(deps):
                continue

            action = node.builder.action
            if type(action) == SCons.Action.FunctionAction:
                funcname = action.function_name()
                if funcname == 'installFunc':
                    assert len(deps) == 1, len(deps)
                    if posix:
                        cmds = ['cp %s %s' % (deps[0], dest_path)]
                    else:
                        cmds = ['cmd.exe /c "copy %s %s' % (deps[0], dest_path)]
                    continue
                else:
                    sys.stderr.write('Unknown FunctionAction, %r: skipping target %r, deps %r\n'
                        % (funcname, dest_path, deps))
                    unknown_targets.append([dest_path, deps])
                    continue
            elif cmds[0].startswith("Generating placeholder library"):
                if posix:
                    cmds = ['/bin/sh -c "uuidgen > ' + dest_path + '"']
                else:
                    cmds = ['cmd.exe /c "uuidgen > ' + dest_path + '"']

            # Filter out headers
            deps = [d for d in deps if not d.endswith(".h") and not d.endswith('.i')]
            # for d in deps:
                # print d

            is_compiler = "gcc" in " ".join(cmds)

            if is_compiler:
                ninja_fh.write('\nbuild %s: cc %s\n'
                               % (dest_path, ' '.join(escape_path(a) for a in deps)))
            else:
                ninja_fh.write('\nbuild %s: cmd %s\n'
                               % (dest_path, ' '.join(escape_path(a) for a in deps)))
            ninja_fh.write('  cmd = %s\n' % ' && '.join(cmds))

        scons_args = [quote_arg(a) for a in sys.argv if filter_arg(a)]

        if not len(unknown_targets):
            print "Processing unknown targets"
            dests = [a[0] for a in unknown_targets]
            deps = list(set( itertools.chain.from_iterable([a[1] for a in unknown_targets])))

            print('\nbuild %s: cmd %s\n'
                           % (' '.join(dests), ' '.join(deps)))
            print('  cmd = %s %s\n' % (' '.join(scons_args), ' '.join(dests)))
            ninja_fh.write('\nbuild %s: cmd %s\n'
                           % (' '.join(dests), ' '.join(deps)))
            ninja_fh.write('  cmd = python.exe %s %s\n' % (' '.join(scons_args), ' '.join(dests)))

        ninja_fh.close()

        # Make the result file visible atomically.
        os.rename(dest_temp, dest_file)
    print sys.argv

    atexit.register(WriteFile)
